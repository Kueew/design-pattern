### 单例模式

#### 定义
一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

#### 为什么要使用单例
* 解决资源冲突：类级别锁、分布式锁、并发队列、单例模式
* 业务上需要全局唯一实例：从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。

#### 如何实现一个单例
* 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
* 考虑对象创建时的线程安全问题；
* 考虑是否支持延迟加载；
* 考虑 getInstance() 性能是否高（是否加锁）。
  
#### 实现方式
* 饿还模式
  * 类加载时，示例已经创建好
  * 实例的创建过程时线程安全的
  * 不支持延迟加载
  * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），希望在程序启动时就将这个实例初始化好，如果资源不够程序启动时就 OOM，这样就可以立即修复，避免在运行过程中程序崩溃
  * 耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题
* 懒汉模式
  * 获取实例时创建实例
  * 实例创建过程需要加锁
  * 不支持高并发
* 双重检测
  * 在懒汉模式的基础，将方法的锁改成类级别锁
  * 在高并发场景下不用每次都加锁
* 静态内部类
  * 基于 java 的静态内部类实现
  * 支持延迟加载
  * 保证线程安全
* 枚举
  * Java 枚举类型本身的特性
  * 线程安全
  
#### 单例存在哪些问题
* 单例对 OOP 特性的支持不友好
  * 一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性
* 单例会隐藏类之间的依赖关系
  * 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。
* 单例对代码的扩展性不友好
  * 单例类在某些情况下会影响代码的扩展性、灵活性。针对数据库连接池、线程池这类的资源池，最好还是不要设计成单例类
* 单例对代码的可测试性不友好
  * 单例类这种硬编码式的使用方式，导致无法实现 mock 替换
* 单例不支持有参数的构造函数

