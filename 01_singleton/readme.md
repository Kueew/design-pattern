### 单例模式

#### 定义
一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

#### 为什么要使用单例
* 解决资源冲突：类级别锁、分布式锁、并发队列、单例模式
* 业务上需要全局唯一实例：从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。

#### 如何实现一个单例
* 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
* 考虑对象创建时的线程安全问题；
* 考虑是否支持延迟加载；
* 考虑 getInstance() 性能是否高（是否加锁）。
  
#### 实现方式
* 饿还模式
  * 类加载时，示例已经创建好
  * 实例的创建过程时线程安全的
  * 不支持延迟加载
  * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），希望在程序启动时就将这个实例初始化好，如果资源不够程序启动时就 OOM，这样就可以立即修复，避免在运行过程中程序崩溃
  * 耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题
* 懒汉模式
  * 获取实例时创建实例
  * 实例创建过程需要加锁
  * 不支持高并发
* 双重检测
  * 在懒汉模式的基础，将方法的锁改成类级别锁
  * 在高并发场景下不用每次都加锁
* 静态内部类
  * 基于 java 的静态内部类实现
  * 支持延迟加载
  * 保证线程安全
* 枚举
  * Java 枚举类型本身的特性
  * 线程安全
  
#### 单例存在哪些问题
* 单例对 OOP 特性的支持不友好
  * 一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性
* 单例会隐藏类之间的依赖关系
  * 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。
* 单例对代码的扩展性不友好
  * 单例类在某些情况下会影响代码的扩展性、灵活性。针对数据库连接池、线程池这类的资源池，最好还是不要设计成单例类
* 单例对代码的可测试性不友好
  * 单例类这种硬编码式的使用方式，导致无法实现 mock 替换
* 单例不支持有参数的构造函数

#### 单例的唯一性
* 进程唯一：进程内唯一，进程间不唯一
* 线程唯一：指的是线程内唯一，线程间可以不唯一
* 集群唯一：进程内唯一，进程间也唯一
  
#### 如何实现线程唯一的单例
通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象

#### 如何实现集群环境下的单例
需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁

#### 如何实现一个多例模式
“单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数